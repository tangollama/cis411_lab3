"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var chai_1 = require("chai");
var testUtils_1 = require("./testUtils");
describe('decreaseKey', function () {
    it('should throw an exception given a non-existent node', function () {
        var heap = new testUtils_1.TestFibonacciHeap();
        chai_1.assert.throws(function () {
            heap.decreaseKey(undefined, 2);
        });
    });
    it('should throw an exception given a new key larger than the old key', function () {
        var heap = new testUtils_1.TestFibonacciHeap();
        chai_1.assert.throws(function () {
            var node = heap.insert(1);
            heap.decreaseKey(node, 2);
        });
    });
    it('should decrease the minimum node', function () {
        var heap = new testUtils_1.TestFibonacciHeap();
        var node1 = heap.insert(1);
        heap.insert(2);
        heap.decreaseKey(node1, -3);
        var key = heap.findMinimumUnsafe().key;
        chai_1.assert.deepEqual(key, node1.key);
        chai_1.assert.equal(key, -3);
    });
    it('should decrease and bubble up a non-minimum node', function () {
        var heap = new testUtils_1.TestFibonacciHeap();
        heap.insert(1);
        var node2 = heap.insert(2);
        heap.decreaseKey(node2, -3);
        var key = heap.findMinimumUnsafe().key;
        chai_1.assert.deepEqual(key, node2.key);
        chai_1.assert.equal(key, -3);
    });
    it('should decrease and bubble up a non-minimum node in a large heap', function () {
        var heap = new testUtils_1.TestFibonacciHeap();
        heap.insert(13);
        heap.insert(26);
        heap.insert(3);
        heap.insert(-6);
        var node5 = heap.insert(27);
        heap.insert(88);
        heap.insert(59);
        heap.insert(-10);
        heap.insert(16);
        heap.decreaseKey(node5, -11);
        chai_1.assert.deepEqual(heap.findMinimumUnsafe().key, node5.key);
    });
    it('should leave a valid tree on a flat Fibonacci heap', function () {
        var heap = new testUtils_1.TestFibonacciHeap();
        heap.insert(13);
        heap.insert(26);
        heap.insert(3);
        heap.insert(-6);
        heap.insert(27);
        var node6 = heap.insert(88);
        heap.insert(59);
        heap.insert(-10);
        heap.insert(16);
        heap.decreaseKey(node6, -8);
        chai_1.assert.deepEqual(heap.extractMinimumUnsafe().key, -10);
        chai_1.assert.deepEqual(heap.extractMinimumUnsafe().key, -8);
        chai_1.assert.deepEqual(heap.extractMinimumUnsafe().key, -6);
        chai_1.assert.deepEqual(heap.extractMinimumUnsafe().key, 3);
        chai_1.assert.deepEqual(heap.extractMinimumUnsafe().key, 13);
        chai_1.assert.deepEqual(heap.extractMinimumUnsafe().key, 16);
        chai_1.assert.deepEqual(heap.extractMinimumUnsafe().key, 26);
        chai_1.assert.deepEqual(heap.extractMinimumUnsafe().key, 27);
        chai_1.assert.deepEqual(heap.extractMinimumUnsafe().key, 59);
    });
    it('should leave a valid tree on a consolidated Fibonacci heap', function () {
        var heap = new testUtils_1.TestFibonacciHeap();
        var node0 = heap.insert(0);
        var node1 = heap.insert(1);
        var node2 = heap.insert(2);
        var node3 = heap.insert(3);
        var node4 = heap.insert(4);
        var node5 = heap.insert(5);
        var node6 = heap.insert(6);
        var node7 = heap.insert(7);
        var node8 = heap.insert(8);
        // Extracting minimum should trigger consolidate.
        //
        //                                    __1
        //                                   / /|
        //                                  5 3 2
        //  0--1--2--3--4--5--6--7--8  ->  /| |
        //                                7 6 4
        //                                |
        //                                8
        //
        chai_1.assert.equal(heap.extractMinimum(), node0);
        // Decrease node 8 to 0
        //
        //      __1
        //     / /|        __1--0
        //    5 3 2       / /|
        //   /| |    ->  5 3 2
        //  7 6 4       /| |
        //  |          7 6 4
        //  8
        //
        heap.decreaseKey(node8, 0);
        chai_1.assert.isTrue(node1.next === node8);
        chai_1.assert.equal(heap.size(), 8);
        chai_1.assert.isTrue(heap.extractMinimum() === node8);
        chai_1.assert.isTrue(heap.extractMinimum() === node1);
        chai_1.assert.isTrue(heap.extractMinimum() === node2);
        chai_1.assert.isTrue(heap.extractMinimum() === node3);
        chai_1.assert.isTrue(heap.extractMinimum() === node4);
        chai_1.assert.isTrue(heap.extractMinimum() === node5);
        chai_1.assert.isTrue(heap.extractMinimum() === node6);
        chai_1.assert.isTrue(heap.extractMinimum() === node7);
        chai_1.assert.isTrue(heap.isEmpty());
    });
    it('should delete the node\'s parent reference after a cut', function () {
        var heap = new testUtils_1.TestFibonacciHeap();
        var node1 = heap.insert(1);
        heap.insert(2);
        var node3 = heap.insert(3);
        chai_1.assert.equal(heap.size(), 3);
        // Trigger a consolidate
        //
        //               2
        //  1--2--3  ->  |
        //               3
        //
        chai_1.assert.equal(heap.extractMinimum(), node1);
        // Decrease 3's key such that it's less than its parent
        //
        //  2      1
        //  |  ->  |
        //  3      2
        //
        heap.decreaseKey(node3, 1);
        // Ensure 1's parent is null (the link to 2 has been cut)
        chai_1.assert.equal(node3.parent, null);
    });
});
//# sourceMappingURL=decrease-key.test.js.map