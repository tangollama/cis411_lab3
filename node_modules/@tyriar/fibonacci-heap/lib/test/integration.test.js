"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var chai_1 = require("chai");
var testUtils_1 = require("./testUtils");
describe('integration', function () {
    it('should work with string keys', function () {
        var heap = new testUtils_1.TestFibonacciHeap();
        var node3 = heap.insert('f');
        var node4 = heap.insert('o');
        var node2 = heap.insert('c');
        var node1 = heap.insert('a');
        var node5 = heap.insert('q');
        chai_1.assert.equal(heap.size(), 5);
        chai_1.assert.deepEqual(heap.extractMinimumUnsafe().key, node1.key);
        chai_1.assert.deepEqual(heap.extractMinimumUnsafe().key, node2.key);
        chai_1.assert.deepEqual(heap.extractMinimumUnsafe().key, node3.key);
        chai_1.assert.deepEqual(heap.extractMinimumUnsafe().key, node4.key);
        chai_1.assert.deepEqual(heap.extractMinimumUnsafe().key, node5.key);
        chai_1.assert.isTrue(heap.isEmpty());
    });
    it('should give an empty heap after inserting and extracting 1000 in-order elements', function () {
        var heap = new testUtils_1.TestFibonacciHeap();
        for (var i = 0; i < 1000; i++) {
            heap.insert(i, i);
        }
        for (var i = 0; i < 1000; i++) {
            heap.extractMinimum();
        }
        chai_1.assert.isTrue(heap.isEmpty());
    });
    it('should give an empty heap after inserting and extracting 1000 reversed elements', function () {
        var heap = new testUtils_1.TestFibonacciHeap();
        for (var i = 0; i < 1000; i++) {
            heap.insert(i, i);
        }
        for (var i = 0; i < 1000; i++) {
            heap.extractMinimum();
        }
        chai_1.assert.isTrue(heap.isEmpty());
    });
    it('should give an empty heap after inserting and extracting 1000 pseudo-randomized elements', function () {
        var heap = new testUtils_1.TestFibonacciHeap();
        for (var i = 0; i < 1000; i++) {
            if (i % 2 === 0) {
                heap.insert(i, i);
            }
            else {
                heap.insert(999 - i, 999 - i);
            }
        }
        for (var i = 0; i < 1000; i++) {
            heap.extractMinimum();
        }
        chai_1.assert.isTrue(heap.isEmpty());
    });
    it('should handle 1000 shuffled elements', function () {
        var heap = new testUtils_1.TestFibonacciHeap();
        var input = [];
        for (var i = 0; i < 1000; i++) {
            input.push(i);
        }
        // shuffle
        for (var i = 0; i < 1000; i++) {
            var swapWith = Math.floor(Math.random() * 1000);
            var temp = input[i];
            input[i] = input[swapWith];
            input[swapWith] = temp;
        }
        // insert
        for (var i = 0; i < 1000; i++) {
            heap.insert(input[i]);
        }
        // extract
        var output = [];
        var errorReported = false;
        var counter = 0;
        while (!heap.isEmpty()) {
            output.push(heap.extractMinimumUnsafe().key);
            if (!errorReported && counter !== output[output.length - 1]) {
                chai_1.assert.fail('the heap property was not maintained (elements in order 0, 1, 2, ..., 997, 998, 999)');
            }
            counter++;
        }
        chai_1.assert.equal(output.length, 1000);
    });
});
//# sourceMappingURL=integration.test.js.map